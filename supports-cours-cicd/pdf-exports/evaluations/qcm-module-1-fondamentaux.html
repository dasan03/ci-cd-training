<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>QCM Module 1 - Fondamentaux CI/CD</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 2cm; line-height: 1.6; }
        h1 { color: #2c3e50; border-bottom: 2px solid #3498db; }
        h2 { color: #34495e; margin-top: 2em; }
        h3 { color: #7f8c8d; }
        code { background: #f8f9fa; padding: 2px 4px; border-radius: 3px; }
        pre { background: #f8f9fa; padding: 1em; border-radius: 5px; overflow-x: auto; }
        li { margin: 0.5em 0; }
        @media print {
            body { margin: 1cm; }
            h1 { page-break-before: always; }
        }
    </style>
</head>
<body>
    <h1>QCM Module 1 - Fondamentaux CI/CD</h1>
    <h1>QCM Module 1 - Fondamentaux CI/CD</h1><br><br>Évaluation des connaissances acquises sur les concepts fondamentaux CI/CD, l'automatisation des tests et les pipelines de base<br><br><h2>Instructions</h2><br><br>[object Object]<br><br><h2>Questions</h2><br><br><h3>Question 1</h3><br><br><strong>Quelle est la différence principale entre l'Intégration Continue (CI) et le Déploiement Continu (CD) ?</strong><br><br>A. CI se concentre sur l'intégration et les tests automatiques, CD sur le déploiement automatisé<br>B. CI concerne uniquement le code, CD concerne uniquement les conteneurs<br>C. Il n'y a aucune différence, ce sont des synonymes<br>D. CI est pour les développeurs, CD est pour les testeurs<br><br><em>Explication: L'Intégration Continue (CI) est une pratique qui consiste à intégrer fréquemment les modifications de code avec des tests automatiques, tandis que le Déploiement Continu (CD) étend cette pratique en automatisant le déploiement jusqu'en production après validation des tests.</em><br><br>---<br><br><h3>Question 2</h3><br><br><strong>Dans la pyramide de test, les tests End-to-End (E2E) doivent représenter la majorité des tests automatisés.</strong><br><br><em>Explication: Faux. Dans la pyramide de test, les tests unitaires doivent représenter environ 70% des tests (base de la pyramide), les tests d'intégration 20%, et les tests E2E seulement 10% (sommet). Les tests E2E sont plus lents, fragiles et coûteux à maintenir.</em><br><br>---<br><br><h3>Question 3</h3><br><br><strong>Quel est l'avantage principal du principe 'Fail Fast' dans un pipeline CI/CD ?</strong><br><br>A. Réduire les coûts en arrêtant le pipeline dès qu'un test échoue<br>B. Accélérer uniquement les tests unitaires<br>C. Permettre de déployer plus rapidement en production<br>D. Éviter d'écrire trop de tests<br><br><em>Explication: Le principe 'Fail Fast' consiste à arrêter le pipeline dès qu'un test échoue, ce qui permet d'économiser du temps et des ressources en évitant d'exécuter les étapes suivantes qui sont vouées à l'échec. Cela fournit aussi un feedback plus rapide aux développeurs.</em><br><br>---<br><br><h3>Question 4</h3><br><br><strong>Associez chaque type de test à sa caractéristique principale :</strong><br><br><em>Explication: Les tests unitaires vérifient des unités de code isolées (fonctions, méthodes), les tests d'intégration vérifient les interactions entre composants, et les tests E2E simulent le parcours utilisateur complet de bout en bout.</em><br><br>---<br><br><h3>Question 5</h3><br><br><strong>Dans GitHub Actions, que représente un 'Job' ?</strong><br><br>A. Un ensemble d'étapes exécutées sur un runner<br>B. Un fichier de configuration YAML<br>C. Un événement qui déclenche le workflow<br>D. Une action réutilisable du marketplace<br><br><em>Explication: Dans GitHub Actions, un Job est un ensemble d'étapes (steps) qui s'exécutent sur le même runner. Les jobs peuvent s'exécuter en parallèle ou séquentiellement selon les dépendances définies avec 'needs'.</em><br><br>---<br><br><h3>Question 6</h3><br><br><strong>Les tests automatisés peuvent complètement remplacer les tests manuels dans tous les cas d'usage.</strong><br><br><em>Explication: Faux. Bien que les tests automatisés soient très utiles pour les tests de régression, de performance et répétitifs, ils ne peuvent pas remplacer complètement les tests manuels, notamment pour les tests exploratoires, d'utilisabilité, d'accessibilité et certains tests créatifs qui nécessitent un jugement humain.</em><br><br>---<br><br><h3>Question 7</h3><br><br><strong>Quelle stratégie de déploiement permet un rollback instantané en cas de problème ?</strong><br><br>A. Rolling Deployment<br>B. Blue-Green Deployment<br>C. Canary Deployment<br>D. Big Bang Deployment<br><br><em>Explication: Le Blue-Green Deployment utilise deux environnements identiques (Blue et Green). Le trafic bascule instantanément du Blue vers le Green lors du déploiement, permettant un rollback immédiat en cas de problème en redirigeant le trafic vers l'environnement précédent.</em><br><br>---<br><br><h3>Question 8</h3><br><br><strong>Parmi ces outils, lesquels sont spécifiquement conçus pour les tests End-to-End ?</strong><br><br>A. Jest et Mocha<br>B. Cypress et Playwright<br>C. ESLint et SonarQube<br>D. Docker et Kubernetes<br><br><em>Explication: Cypress et Playwright sont des frameworks spécialement conçus pour les tests End-to-End, permettant d'automatiser les interactions avec les navigateurs web. Jest et Mocha sont plutôt orientés tests unitaires, ESLint/SonarQube pour l'analyse statique, et Docker/Kubernetes pour la containerisation et l'orchestration.</em><br><br>---<br><br>
</body>
</html>